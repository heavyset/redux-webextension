"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exposeStore = exports.connectStore = undefined;

var _redux = require("redux");

const randomString = () => Math.random().toString(36).substring(7).split("").join(".");
/**
 * Exposes a Redux store in a background page of a WebExtension to other
 * extension pages, such as content scripts and popups.
 */


const SYNC_ACTION = `@@redux-webextension/SYNC${randomString()}`;
const STORE_CLIENT_PREFIX = "storeClient:";

function defaultPortFactory(name) {
  return chrome.runtime.connect({
    name: `storeClient:${name}`
  });
}

/**
 * Connect to the Redux store in a background page.
 *
 * @param {string} name - A name that identifies the connecting component,
 *     useful for debugging.
 *
 * @returns {object} An object conforming to the Redux store API that can be
 *    used transparently with code expecting a Redux store object, such as
 *    the React redux bindings.
 *
 * @todo Make this promise/callback based so we can ensure code only runs once
 *     a valid connection is established to a background page.
 */
function connectStore(name = "default", portFactory = defaultPortFactory) {
  let port;

  let store = (0, _redux.createStore)((state, action) => {
    return action.type == SYNC_ACTION ? action.state : state;
  });

  function dispatch(action) {
    port.postMessage({ type: "dispatch", payload: action });
  }

  function replaceReducer() {
    throw new Error("replaceReducer doesn't exist in remote stores");
  }

  port = portFactory(name);
  port.onMessage.addListener(message => {
    switch (message.type) {
      case "stateSync":
        store.dispatch({ type: SYNC_ACTION, state: message.payload });
        break;
      default:
        throw new Error(`Unknown message type: ${message.type}`);
    }
  });

  function executor(resolve, reject) {
    let unsubscribe = store.subscribe(() => {
      unsubscribe();
      resolve({
        subscribe: store.subscribe,
        getState: store.getState,
        dispatch,
        replaceReducer
      });
    });
    port.postMessage({ type: "requestStateSync" });
  }

  return new Promise(executor);
}

function defaultConnectListener(callback) {
  function listener(port) {
    if (port.name.indexOf(STORE_CLIENT_PREFIX) !== 0) {
      return;
    }

    callback(port);
  }

  chrome.runtime.onConnect.addListener(listener);
}

/**
 * Expose the Redux store in a background page to other parts of an extension.
 *
 * @param {object} store - The Redux store to expose.
 * @param {Function} addConnectListener - A function that will repeatedly call
 *     a given callback with a newly connected port. If not supplied, an
 *     appropriate default is used.
 * @param {Function} disconnectCallback - A function that will be called when
 *     the port disconnects with the disconnected port and the store. This is
 *     useful for doing state cleanup if necessary.
 */
function exposeStore(store, addConnectListener, disconnectCallback) {
  if (!addConnectListener) {
    addConnectListener = defaultConnectListener;
  }

  addConnectListener(port => {
    registerPortListeners(store, port, disconnectCallback);
  });
}

/**
 * Bind a Redux store to handle events generated by a port.
 *
 * @param {object} store - The Redux store to expose.
 * @param {object} port - The port that will generate events.
 * @param {Function} disconnectCallback - A function that will be called when
 *     the port disconnects with the disconnected port and the store. This is
 *     useful for doing state cleanup if necessary.
 */
function registerPortListeners(store, port, disconnectCallback) {
  function sendStateSync() {
    port.postMessage({
      type: "stateSync",
      payload: store.getState()
    });
  }

  function messageListener(message) {
    switch (message.type) {
      case "dispatch":
        store.dispatch(message.payload);
        break;
      case "requestStateSync":
        sendStateSync();
        break;
      default:
        throw new Error(`Unknown message type: ${message.type}`);
    }
  }

  function handleDisconnect(disconnectedPort) {
    unsubscribe();
    if (disconnectCallback) {
      disconnectCallback(disconnectedPort, store);
    }
  }

  let unsubscribe = store.subscribe(sendStateSync);

  port.onMessage.addListener(messageListener);
  port.onDisconnect.addListener(handleDisconnect);
}

exports.connectStore = connectStore;
exports.exposeStore = exposeStore;